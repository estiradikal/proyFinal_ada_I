<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Informe - Mini Proyecto ADA I</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', 'Times New Roman', serif;
            line-height: 1.6;
            color: #333;
            max-width: 210mm;
            margin: 0 auto;
            padding: 20mm;
            background: #fff;
        }

        /* Estilos para impresion */
        @media print {
            body {
                padding: 15mm;
            }
            .page-break {
                page-break-before: always;
            }
            h2 {
                page-break-after: avoid;
            }
            table, figure {
                page-break-inside: avoid;
            }
        }

        /* Encabezado */
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #c41e3a;
        }

        .logo {
            width: 80px;
            height: 80px;
            margin: 0 auto 15px;
            background: #c41e3a;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 24px;
        }

        .university {
            color: #c41e3a;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 20px;
        }

        h1 {
            color: #1a1a1a;
            font-size: 28px;
            margin-bottom: 5px;
        }

        .subtitle {
            color: #666;
            font-size: 18px;
            margin-bottom: 20px;
        }

        .info {
            font-size: 14px;
            color: #555;
        }

        .info p {
            margin: 5px 0;
        }

        /* Integrantes */
        .integrantes {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin: 30px 0;
        }

        .integrantes h3 {
            color: #c41e3a;
            margin-bottom: 15px;
            font-size: 16px;
        }

        .integrantes ul {
            list-style: none;
            columns: 2;
        }

        .integrantes li {
            padding: 5px 0;
            font-size: 14px;
        }

        /* Tabla de contenidos */
        .toc {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 8px;
            margin: 30px 0;
        }

        .toc h2 {
            color: #1a1a1a;
            font-size: 18px;
            margin-bottom: 15px;
            border-bottom: 2px solid #c41e3a;
            padding-bottom: 10px;
        }

        .toc ol {
            padding-left: 20px;
        }

        .toc li {
            padding: 5px 0;
            font-size: 14px;
        }

        .toc a {
            color: #333;
            text-decoration: none;
        }

        .toc a:hover {
            color: #c41e3a;
        }

        /* Secciones */
        h2 {
            color: #c41e3a;
            font-size: 22px;
            margin: 40px 0 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #c41e3a;
        }

        h3 {
            color: #1a1a1a;
            font-size: 18px;
            margin: 25px 0 15px;
        }

        h4 {
            color: #444;
            font-size: 16px;
            margin: 20px 0 10px;
        }

        p {
            margin: 10px 0;
            text-align: justify;
        }

        /* Tablas */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 14px;
        }

        th {
            background: #c41e3a;
            color: white;
            padding: 12px 10px;
            text-align: left;
            font-weight: bold;
        }

        td {
            padding: 10px;
            border-bottom: 1px solid #ddd;
        }

        tr:nth-child(even) {
            background: #f8f9fa;
        }

        tr:hover {
            background: #f0f0f0;
        }

        /* Codigo */
        pre {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            line-height: 1.5;
            margin: 15px 0;
        }

        code {
            font-family: 'Consolas', 'Monaco', monospace;
            background: #f0f0f0;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 13px;
        }

        pre code {
            background: none;
            padding: 0;
        }

        .keyword { color: #569cd6; }
        .function { color: #dcdcaa; }
        .string { color: #ce9178; }
        .comment { color: #6a9955; }
        .number { color: #b5cea8; }

        /* Listas */
        ul, ol {
            margin: 10px 0 10px 25px;
        }

        li {
            margin: 5px 0;
        }

        /* Graficas */
        .chart-container {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .chart-title {
            font-weight: bold;
            color: #333;
            margin-bottom: 15px;
            text-align: center;
        }

        .chart {
            width: 100%;
            height: 300px;
            position: relative;
        }

        /* Graficas SVG */
        svg {
            width: 100%;
            height: 100%;
        }

        .axis line, .axis path {
            stroke: #333;
            stroke-width: 1;
        }

        .axis text {
            font-size: 12px;
            fill: #333;
        }

        .grid line {
            stroke: #e0e0e0;
            stroke-width: 0.5;
        }

        .line-merge {
            fill: none;
            stroke: #c41e3a;
            stroke-width: 2;
        }

        .line-heap {
            fill: none;
            stroke: #2196F3;
            stroke-width: 2;
        }

        .dot-merge {
            fill: #c41e3a;
        }

        .dot-heap {
            fill: #2196F3;
        }

        .legend {
            font-size: 12px;
        }

        /* Cajas de informacion */
        .info-box {
            background: #e3f2fd;
            border-left: 4px solid #2196F3;
            padding: 15px 20px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }

        .warning-box {
            background: #fff3e0;
            border-left: 4px solid #ff9800;
            padding: 15px 20px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }

        .success-box {
            background: #e8f5e9;
            border-left: 4px solid #4caf50;
            padding: 15px 20px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }

        /* Diagrama de estructura */
        .structure-diagram {
            font-family: 'Consolas', monospace;
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.4;
        }

        /* Footer */
        .footer {
            margin-top: 50px;
            padding-top: 20px;
            border-top: 2px solid #c41e3a;
            text-align: center;
            font-size: 12px;
            color: #666;
        }

        /* Barras comparativas */
        .bar-chart {
            margin: 20px 0;
        }

        .bar-row {
            display: flex;
            align-items: center;
            margin: 8px 0;
        }

        .bar-label {
            width: 80px;
            font-size: 12px;
            text-align: right;
            padding-right: 10px;
        }

        .bar-container {
            flex: 1;
            display: flex;
            gap: 5px;
        }

        .bar {
            height: 25px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            padding-left: 8px;
            font-size: 11px;
            color: white;
            min-width: 50px;
        }

        .bar-merge {
            background: linear-gradient(90deg, #c41e3a, #e53935);
        }

        .bar-heap {
            background: linear-gradient(90deg, #1976D2, #2196F3);
        }

        /* Formulas matematicas */
        .formula {
            background: #f8f9fa;
            padding: 15px 20px;
            border-radius: 8px;
            text-align: center;
            font-family: 'Times New Roman', serif;
            font-size: 18px;
            margin: 15px 0;
            border: 1px solid #ddd;
        }

        .formula-inline {
            font-family: 'Times New Roman', serif;
            font-style: italic;
        }
    </style>
</head>
<body>

    <!-- PORTADA -->
    <div class="header">
        <div class="logo">UV</div>
        <div class="university">Universidad del Valle</div>
        <h1>Informe - Mini Proyecto</h1>
        <div class="subtitle">Analisis y Diseno de Algoritmos I</div>
        <div class="info">
            <p><strong>Profesor:</strong> Jesus Alexander Aranda Bueno</p>
            <p><strong>Monitor:</strong> Samuel Galindo Cuevas</p>
            <p><strong>Fecha:</strong> Diciembre 2025</p>
        </div>
    </div>

    <div class="integrantes">
        <h3>Integrantes del Equipo</h3>
        <ul>
            <li><strong>Daniel Enrique Echeverria Villa</strong> - 2177465</li>
            <li><strong>Estiven Andres Martinez Granados</strong> - 2179687</li>
            <li><strong>Juan Carlos Cruz</strong> - 1824389</li>
            <li><strong>Juan Esteban Rodriguez Valencia</strong> - 2042282</li>
        </ul>
    </div>

    <!-- TABLA DE CONTENIDOS -->
    <div class="toc">
        <h2>Tabla de Contenidos</h2>
        <ol>
            <li><a href="#introduccion">Introduccion</a></li>
            <li><a href="#descripcion">Descripcion del Problema</a></li>
            <li><a href="#solucion1">Solucion 1: Listas + Merge Sort</a></li>
            <li><a href="#solucion2">Solucion 2: Diccionarios + Heap Sort</a></li>
            <li><a href="#analisis">Analisis Experimental de Resultados</a></li>
            <li><a href="#conclusiones">Conclusiones</a></li>
        </ol>
    </div>

    <div class="page-break"></div>

    <!-- 1. INTRODUCCION -->
    <h2 id="introduccion">1. Introduccion</h2>

    <p>
        En este informe se presenta el analisis de un problema de gestion deportiva que requiere
        evaluar el rendimiento de jugadores, equipos y sedes para apoyar la toma de decisiones
        estrategicas. El proyecto consiste en el diseno e implementacion de dos soluciones
        algoritmicas distintas, utilizando diferentes estructuras de datos y algoritmos de
        ordenamiento implementados manualmente en Python.
    </p>

    <p>
        El objetivo principal es ordenar y clasificar la informacion de una asociacion deportiva
        para identificar cuales equipos y jugadores merecen mas recursos y cuales requieren
        planes de mejora en su rendimiento.
    </p>

    <div class="info-box">
        <strong>Objetivo del Proyecto:</strong> Implementar dos soluciones algoritmicas diferentes
        que resuelvan el problema de ordenamiento jerarquico de una organizacion deportiva,
        utilizando estructuras de datos y algoritmos distintos en cada solucion.
    </div>

    <!-- 2. DESCRIPCION DEL PROBLEMA -->
    <h2 id="descripcion">2. Descripcion del Problema</h2>

    <h3>2.1 Contexto</h3>
    <p>
        Una asociacion de deportes desea realizar un analisis a fondo de su organizacion deportiva.
        La organizacion tiene la siguiente estructura jerarquica:
    </p>

    <div class="structure-diagram">
<pre>
Asociacion
    |
    +-- Sede 1 (nombre)
    |       |
    |       +-- Equipo 1 (deporte)
    |       |       |-- Jugador 1 (id, nombre, edad, rendimiento)
    |       |       |-- Jugador 2
    |       |       +-- ...
    |       |
    |       +-- Equipo 2
    |               +-- ...
    |
    +-- Sede 2
            +-- ...
</pre>
    </div>

    <h3>2.2 Parametros del Sistema</h3>
    <table>
        <thead>
            <tr>
                <th>Parametro</th>
                <th>Descripcion</th>
                <th>Restricciones</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>K</strong></td>
                <td>Numero de sedes</td>
                <td>Entero positivo</td>
            </tr>
            <tr>
                <td><strong>M</strong></td>
                <td>Numero de equipos por sede</td>
                <td>Entero positivo</td>
            </tr>
            <tr>
                <td><strong>Nmin</strong></td>
                <td>Numero minimo de jugadores por equipo</td>
                <td>Nmin &lt; Nmax</td>
            </tr>
            <tr>
                <td><strong>Nmax</strong></td>
                <td>Numero maximo de jugadores por equipo</td>
                <td>Entero positivo</td>
            </tr>
            <tr>
                <td><strong>Rendimiento</strong></td>
                <td>Valor de rendimiento del jugador</td>
                <td>1 a 100, entero</td>
            </tr>
        </tbody>
    </table>

    <h3>2.3 Requerimientos de Ordenamiento</h3>
    <ol>
        <li><strong>Jugadores dentro de cada equipo:</strong> Ordenados ascendentemente por rendimiento.
            En caso de empate, el jugador de mayor edad va primero.</li>
        <li><strong>Equipos dentro de cada sede:</strong> Ordenados ascendentemente por rendimiento promedio.
            En caso de empate, el equipo con mas jugadores va primero.</li>
        <li><strong>Sedes:</strong> Ordenadas ascendentemente por el promedio de rendimientos de sus equipos.
            En caso de empate, la sede con mas jugadores totales va primero.</li>
        <li><strong>Ranking global:</strong> Lista de todos los jugadores ordenados por rendimiento ascendente.</li>
    </ol>

    <h3>2.4 Estadisticas Requeridas</h3>
    <table>
        <thead>
            <tr>
                <th>Estadistica</th>
                <th>Descripcion</th>
            </tr>
        </thead>
        <tbody>
            <tr><td>Equipo con mayor rendimiento</td><td>Equipo con el promedio mas alto</td></tr>
            <tr><td>Equipo con menor rendimiento</td><td>Equipo con el promedio mas bajo</td></tr>
            <tr><td>Jugador con mayor rendimiento</td><td>Jugador con rendimiento maximo</td></tr>
            <tr><td>Jugador con menor rendimiento</td><td>Jugador con rendimiento minimo</td></tr>
            <tr><td>Jugador mas joven</td><td>Jugador con menor edad</td></tr>
            <tr><td>Jugador mas veterano</td><td>Jugador con mayor edad</td></tr>
            <tr><td>Promedio de edad</td><td>Media aritmetica de edades</td></tr>
            <tr><td>Promedio de rendimiento</td><td>Media aritmetica de rendimientos</td></tr>
        </tbody>
    </table>

    <div class="page-break"></div>

    <!-- 3. SOLUCION 1 -->
    <h2 id="solucion1">3. Solucion 1: Listas + Merge Sort</h2>

    <h3>3.1 Idea General</h3>
    <p>
        La primera solucion se basa en el uso de <strong>estructuras secuenciales (listas)</strong>
        para almacenar jugadores, equipos y sedes. Para realizar los distintos ordenamientos requeridos,
        se implementa manualmente el algoritmo <strong>Merge Sort</strong>, siguiendo el paradigma de
        <strong>divide y venceras</strong>.
    </p>

    <h3>3.2 Estructuras de Datos Utilizadas</h3>
    <table>
        <thead>
            <tr>
                <th>Estructura</th>
                <th>Uso</th>
                <th>Justificacion</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Lista de Jugadores</td>
                <td>Almacenar jugadores en cada equipo</td>
                <td>Acceso secuencial O(1), facil de dividir</td>
            </tr>
            <tr>
                <td>Lista de Equipos</td>
                <td>Almacenar equipos en cada sede</td>
                <td>Permite ordenamiento eficiente</td>
            </tr>
            <tr>
                <td>Lista de Sedes</td>
                <td>Almacenar todas las sedes</td>
                <td>Estructura simple y eficiente</td>
            </tr>
        </tbody>
    </table>

    <h4>Implementacion de Clases:</h4>
    <pre><code><span class="keyword">class</span> <span class="function">Jugador</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self, nombre, edad, rendimiento):
        self.id = Jugador._next_id
        self.nombre = nombre
        self.edad = edad
        self.rendimiento = rendimiento

<span class="keyword">class</span> <span class="function">Equipo</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self, deporte, jugadores):  <span class="comment"># jugadores es una lista</span>
        self.deporte = deporte
        self.jugadores = jugadores
        self.promedio = self.calcular_promedio()

<span class="keyword">class</span> <span class="function">Sede</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self, nombre, equipos):  <span class="comment"># equipos es una lista</span>
        self.nombre = nombre
        self.equipos = equipos
        self.promedio = self.calcular_promedio()</code></pre>

    <h3>3.3 Algoritmo: Merge Sort</h3>

    <h4>3.3.1 Descripcion</h4>
    <p>
        Merge Sort es un algoritmo de ordenamiento basado en el paradigma <strong>divide y venceras</strong>:
    </p>
    <ol>
        <li><strong>Dividir:</strong> Se divide el arreglo en dos mitades</li>
        <li><strong>Conquistar:</strong> Se ordena recursivamente cada mitad</li>
        <li><strong>Combinar:</strong> Se mezclan las dos mitades ordenadas</li>
    </ol>

    <h4>3.3.2 Pseudocodigo</h4>
    <pre><code><span class="function">MERGE-SORT</span>(A, inicio, fin)
    <span class="keyword">si</span> inicio < fin <span class="keyword">entonces</span>
        medio = (inicio + fin) / 2
        MERGE-SORT(A, inicio, medio)
        MERGE-SORT(A, medio + 1, fin)
        MERGE(A, inicio, medio, fin)

<span class="function">MERGE</span>(A, inicio, medio, fin)
    n1 = medio - inicio + 1
    n2 = fin - medio
    crear arreglos L[1..n1] y R[1..n2]

    <span class="keyword">para</span> i = 1 <span class="keyword">hasta</span> n1
        L[i] = A[inicio + i - 1]
    <span class="keyword">para</span> j = 1 <span class="keyword">hasta</span> n2
        R[j] = A[medio + j]

    i = 1, j = 1, k = inicio

    <span class="keyword">mientras</span> i <= n1 <span class="keyword">y</span> j <= n2
        <span class="keyword">si</span> L[i] <= R[j] <span class="keyword">entonces</span>
            A[k] = L[i]
            i = i + 1
        <span class="keyword">sino</span>
            A[k] = R[j]
            j = j + 1
        k = k + 1

    <span class="comment">// copiar elementos restantes de L[] y R[]</span></code></pre>

    <h4>3.3.3 Implementacion para Jugadores (con desempate)</h4>
    <pre><code><span class="keyword">def</span> <span class="function">merge_sort_jugadores</span>(arr):
    <span class="keyword">if</span> len(arr) <= <span class="number">1</span>:
        <span class="keyword">return</span> arr
    mid = len(arr) // <span class="number">2</span>
    left = merge_sort_jugadores(arr[:mid])
    right = merge_sort_jugadores(arr[mid:])
    <span class="keyword">return</span> merge_jugadores(left, right)

<span class="keyword">def</span> <span class="function">merge_jugadores</span>(left, right):
    result = []
    i = j = <span class="number">0</span>
    <span class="keyword">while</span> i < len(left) <span class="keyword">and</span> j < len(right):
        <span class="comment"># Orden ascendente por rendimiento</span>
        <span class="keyword">if</span> left[i].rendimiento < right[j].rendimiento:
            result.append(left[i])
            i += <span class="number">1</span>
        <span class="keyword">elif</span> left[i].rendimiento > right[j].rendimiento:
            result.append(right[j])
            j += <span class="number">1</span>
        <span class="keyword">else</span>:
            <span class="comment"># Empate: mayor edad primero</span>
            <span class="keyword">if</span> left[i].edad >= right[j].edad:
                result.append(left[i])
                i += <span class="number">1</span>
            <span class="keyword">else</span>:
                result.append(right[j])
                j += <span class="number">1</span>
    result.extend(left[i:])
    result.extend(right[j:])
    <span class="keyword">return</span> result</code></pre>

    <h3>3.4 Complejidad Computacional</h3>
    <table>
        <thead>
            <tr>
                <th>Operacion</th>
                <th>Complejidad Temporal</th>
                <th>Complejidad Espacial</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Merge Sort Jugadores</td>
                <td>O(n log n)</td>
                <td>O(n)</td>
            </tr>
            <tr>
                <td>Merge Sort Equipos</td>
                <td>O(m log m)</td>
                <td>O(m)</td>
            </tr>
            <tr>
                <td>Merge Sort Sedes</td>
                <td>O(k log k)</td>
                <td>O(k)</td>
            </tr>
            <tr>
                <td>Ranking Global</td>
                <td>O(N log N)</td>
                <td>O(N)</td>
            </tr>
            <tr>
                <td>Calcular Estadisticas</td>
                <td>O(N)</td>
                <td>O(1)</td>
            </tr>
        </tbody>
    </table>

    <div class="info-box">
        <strong>Donde:</strong><br>
        n = numero de jugadores por equipo | m = numero de equipos por sede<br>
        k = numero de sedes | N = numero total de jugadores
    </div>

    <h4>Justificacion Teorica - Teorema Maestro:</h4>
    <div class="formula">
        T(n) = 2T(n/2) + O(n)
    </div>
    <p>
        Aplicando el Teorema Maestro (caso 2): a = 2, b = 2, f(n) = n<br>
        log<sub>b</sub>(a) = log<sub>2</sub>(2) = 1, y f(n) = &Theta;(n<sup>1</sup>)
    </p>
    <div class="formula">
        <strong>T(n) = &Theta;(n log n)</strong>
    </div>

    <div class="page-break"></div>

    <!-- 4. SOLUCION 2 -->
    <h2 id="solucion2">4. Solucion 2: Diccionarios + Heap Sort</h2>

    <h3>4.1 Idea General</h3>
    <p>
        La segunda solucion emplea <strong>estructuras asociativas (diccionarios)</strong> para
        almacenar los jugadores dentro de los equipos y los equipos dentro de las sedes.
        Para el ordenamiento se implementa manualmente el algoritmo <strong>Heap Sort</strong>,
        utilizando un <strong>min-heap</strong>.
    </p>

    <h3>4.2 Estructuras de Datos Utilizadas</h3>
    <table>
        <thead>
            <tr>
                <th>Estructura</th>
                <th>Uso</th>
                <th>Justificacion</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Diccionario de Jugadores</td>
                <td>Jugadores indexados por ID</td>
                <td>Busqueda O(1) por ID</td>
            </tr>
            <tr>
                <td>Diccionario de Equipos</td>
                <td>Equipos indexados por posicion</td>
                <td>Acceso rapido y flexible</td>
            </tr>
            <tr>
                <td>Lista de Sedes</td>
                <td>Almacenar sedes</td>
                <td>Necesario para ordenamiento</td>
            </tr>
        </tbody>
    </table>

    <h4>Implementacion de Clases:</h4>
    <pre><code><span class="keyword">class</span> <span class="function">Equipo</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self, deporte, jugadores_lista):
        self.deporte = deporte
        <span class="comment"># Usar diccionario en lugar de lista</span>
        self.jugadores = {}
        <span class="keyword">for</span> j <span class="keyword">in</span> jugadores_lista:
            self.jugadores[j.id] = j
        self.promedio = self.calcular_promedio()

<span class="keyword">class</span> <span class="function">Sede</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self, nombre, equipos_lista):
        self.nombre = nombre
        <span class="comment"># Usar diccionario en lugar de lista</span>
        self.equipos = {}
        <span class="keyword">for</span> i, e <span class="keyword">in</span> enumerate(equipos_lista):
            self.equipos[i] = e</code></pre>

    <h3>4.3 Algoritmo: Heap Sort</h3>

    <h4>4.3.1 Descripcion</h4>
    <p>
        Heap Sort utiliza una estructura de datos llamada <strong>heap</strong> (monticulo)
        para ordenar elementos:
    </p>
    <ol>
        <li><strong>Construir el heap:</strong> Convertir el arreglo en un min-heap</li>
        <li><strong>Extraer elementos:</strong> Extraer el minimo repetidamente para obtener orden ascendente</li>
    </ol>

    <h4>4.3.2 Propiedades del Min-Heap</h4>
    <ul>
        <li>Es un arbol binario completo</li>
        <li>El valor de cada nodo es menor o igual que el de sus hijos</li>
        <li>El minimo siempre esta en la raiz</li>
    </ul>

    <div class="info-box">
        <strong>Representacion en arreglo:</strong><br>
        Hijo izquierdo de i: 2i + 1<br>
        Hijo derecho de i: 2i + 2<br>
        Padre de i: (i - 1) / 2
    </div>

    <h4>4.3.3 Pseudocodigo</h4>
    <pre><code><span class="function">HEAPSORT</span>(A)
    BUILD-MIN-HEAP(A)
    resultado = []
    <span class="keyword">para</span> i = 1 <span class="keyword">hasta</span> n
        resultado.agregar(A[0])  <span class="comment">// Extraer minimo</span>
        A[0] = A[ultimo]
        eliminar ultimo elemento
        SIFT-DOWN(A, 0)
    <span class="keyword">retornar</span> resultado

<span class="function">BUILD-MIN-HEAP</span>(A)
    n = longitud(A)
    <span class="keyword">para</span> i = (n/2 - 1) <span class="keyword">hasta</span> 0
        SIFT-DOWN(A, i)

<span class="function">SIFT-DOWN</span>(A, i)
    menor = i
    izquierdo = 2*i + 1
    derecho = 2*i + 2

    <span class="keyword">si</span> izquierdo < n <span class="keyword">y</span> A[izquierdo] < A[menor]
        menor = izquierdo

    <span class="keyword">si</span> derecho < n <span class="keyword">y</span> A[derecho] < A[menor]
        menor = derecho

    <span class="keyword">si</span> menor != i
        intercambiar A[i] con A[menor]
        SIFT-DOWN(A, menor)</code></pre>

    <h4>4.3.4 Implementacion para Jugadores</h4>
    <pre><code><span class="keyword">def</span> <span class="function">comparar_jugadores</span>(j1, j2):
    <span class="string">"""Retorna True si j1 debe ir antes que j2."""</span>
    <span class="keyword">if</span> j1.rendimiento < j2.rendimiento:
        <span class="keyword">return</span> <span class="keyword">True</span>
    <span class="keyword">elif</span> j1.rendimiento > j2.rendimiento:
        <span class="keyword">return</span> <span class="keyword">False</span>
    <span class="keyword">else</span>:
        <span class="comment"># Mismo rendimiento: mayor edad primero</span>
        <span class="keyword">if</span> j1.edad > j2.edad:
            <span class="keyword">return</span> <span class="keyword">True</span>
        <span class="keyword">elif</span> j1.edad < j2.edad:
            <span class="keyword">return</span> <span class="keyword">False</span>
        <span class="keyword">else</span>:
            <span class="keyword">return</span> j1.id < j2.id  <span class="comment"># Estabilidad</span>

<span class="keyword">def</span> <span class="function">sift_down_jugadores</span>(arr, n, i):
    smallest = i
    left = <span class="number">2</span> * i + <span class="number">1</span>
    right = <span class="number">2</span> * i + <span class="number">2</span>

    <span class="keyword">if</span> left < n <span class="keyword">and</span> comparar_jugadores(arr[left], arr[smallest]):
        smallest = left
    <span class="keyword">if</span> right < n <span class="keyword">and</span> comparar_jugadores(arr[right], arr[smallest]):
        smallest = right

    <span class="keyword">if</span> smallest != i:
        arr[i], arr[smallest] = arr[smallest], arr[i]
        sift_down_jugadores(arr, n, smallest)</code></pre>

    <h3>4.4 Complejidad Computacional</h3>
    <table>
        <thead>
            <tr>
                <th>Operacion</th>
                <th>Complejidad Temporal</th>
                <th>Complejidad Espacial</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Construccion del Heap</td>
                <td>O(n)</td>
                <td>O(1)</td>
            </tr>
            <tr>
                <td>Heap Sort Completo</td>
                <td>O(n log n)</td>
                <td>O(n)</td>
            </tr>
            <tr>
                <td>Ranking Global</td>
                <td>O(N log N)</td>
                <td>O(N)</td>
            </tr>
        </tbody>
    </table>

    <div class="formula">
        <strong>Complejidad Total: O(n) + O(n log n) = O(n log n)</strong>
    </div>

    <div class="page-break"></div>

    <!-- 5. ANALISIS EXPERIMENTAL -->
    <h2 id="analisis">5. Analisis Experimental de Resultados</h2>

    <h3>5.1 Metodologia</h3>
    <p>
        Para el analisis experimental se utilizaron multiples archivos de entrada ubicados en la
        carpeta <code>inputs_tamanos/</code>, con diferentes tamanos. Cada archivo fue ejecutado
        con ambas soluciones, midiendo el tiempo total de ejecucion desde el inicio del
        procesamiento hasta la generacion de resultados y estadisticas.
    </p>

    <div class="info-box">
        <strong>Entorno de pruebas:</strong><br>
        Sistema Operativo: Windows<br>
        Lenguaje: Python 3.x<br>
        Medicion: Modulo <code>time</code> de Python
    </div>

    <h3>5.2 Resultados Obtenidos</h3>

    <h4>Tabla de Tiempos de Ejecucion</h4>
    <table>
        <thead>
            <tr>
                <th>Tamano (elementos)</th>
                <th>Solucion 1 (Merge Sort)</th>
                <th>Solucion 2 (Heap Sort)</th>
                <th>Diferencia</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>115</td>
                <td>0.00075 s</td>
                <td>0.00108 s</td>
                <td style="color: #c41e3a;">+44%</td>
            </tr>
            <tr>
                <td>211</td>
                <td>0.00168 s</td>
                <td>0.00204 s</td>
                <td style="color: #c41e3a;">+21%</td>
            </tr>
            <tr>
                <td>324</td>
                <td>0.00297 s</td>
                <td>0.00311 s</td>
                <td style="color: #c41e3a;">+5%</td>
            </tr>
            <tr>
                <td>444</td>
                <td>0.00304 s</td>
                <td>0.00597 s</td>
                <td style="color: #c41e3a;">+96%</td>
            </tr>
            <tr>
                <td>624</td>
                <td>0.00503 s</td>
                <td>0.00890 s</td>
                <td style="color: #c41e3a;">+77%</td>
            </tr>
            <tr>
                <td>1055</td>
                <td>0.01591 s</td>
                <td>0.02502 s</td>
                <td style="color: #c41e3a;">+57%</td>
            </tr>
            <tr>
                <td>1583</td>
                <td>0.02210 s</td>
                <td>0.03881 s</td>
                <td style="color: #c41e3a;">+76%</td>
            </tr>
            <tr>
                <td>2110</td>
                <td>0.04891 s</td>
                <td>0.05652 s</td>
                <td style="color: #c41e3a;">+16%</td>
            </tr>
        </tbody>
    </table>

    <h3>5.3 Graficas Comparativas</h3>

    <h4>Grafica 1: Tamano de Entrada vs Tiempo de Ejecucion</h4>
    <div class="chart-container">
        <div class="chart-title">Comparacion de Tiempos de Ejecucion</div>
        <svg viewBox="0 0 600 320">
            <!-- Ejes -->
            <line x1="60" y1="280" x2="580" y2="280" stroke="#333" stroke-width="2"/>
            <line x1="60" y1="280" x2="60" y2="30" stroke="#333" stroke-width="2"/>

            <!-- Grid horizontal -->
            <line x1="60" y1="230" x2="580" y2="230" stroke="#e0e0e0" stroke-width="1"/>
            <line x1="60" y1="180" x2="580" y2="180" stroke="#e0e0e0" stroke-width="1"/>
            <line x1="60" y1="130" x2="580" y2="130" stroke="#e0e0e0" stroke-width="1"/>
            <line x1="60" y1="80" x2="580" y2="80" stroke="#e0e0e0" stroke-width="1"/>

            <!-- Etiquetas Y -->
            <text x="50" y="285" font-size="11" text-anchor="end">0</text>
            <text x="50" y="235" font-size="11" text-anchor="end">0.015</text>
            <text x="50" y="185" font-size="11" text-anchor="end">0.030</text>
            <text x="50" y="135" font-size="11" text-anchor="end">0.045</text>
            <text x="50" y="85" font-size="11" text-anchor="end">0.060</text>

            <!-- Etiquetas X -->
            <text x="85" y="298" font-size="10" text-anchor="middle">115</text>
            <text x="145" y="298" font-size="10" text-anchor="middle">211</text>
            <text x="205" y="298" font-size="10" text-anchor="middle">324</text>
            <text x="265" y="298" font-size="10" text-anchor="middle">444</text>
            <text x="325" y="298" font-size="10" text-anchor="middle">624</text>
            <text x="400" y="298" font-size="10" text-anchor="middle">1055</text>
            <text x="480" y="298" font-size="10" text-anchor="middle">1583</text>
            <text x="560" y="298" font-size="10" text-anchor="middle">2110</text>

            <!-- Linea Merge Sort -->
            <polyline
                points="85,277 145,274 205,270 265,270 325,263 400,227 480,206 560,117"
                fill="none" stroke="#c41e3a" stroke-width="3"/>

            <!-- Linea Heap Sort -->
            <polyline
                points="85,276 145,273 205,269 265,260 325,250 400,197 480,151 560,92"
                fill="none" stroke="#2196F3" stroke-width="3"/>

            <!-- Puntos Merge Sort -->
            <circle cx="85" cy="277" r="5" fill="#c41e3a"/>
            <circle cx="145" cy="274" r="5" fill="#c41e3a"/>
            <circle cx="205" cy="270" r="5" fill="#c41e3a"/>
            <circle cx="265" cy="270" r="5" fill="#c41e3a"/>
            <circle cx="325" cy="263" r="5" fill="#c41e3a"/>
            <circle cx="400" cy="227" r="5" fill="#c41e3a"/>
            <circle cx="480" cy="206" r="5" fill="#c41e3a"/>
            <circle cx="560" cy="117" r="5" fill="#c41e3a"/>

            <!-- Puntos Heap Sort -->
            <circle cx="85" cy="276" r="5" fill="#2196F3"/>
            <circle cx="145" cy="273" r="5" fill="#2196F3"/>
            <circle cx="205" cy="269" r="5" fill="#2196F3"/>
            <circle cx="265" cy="260" r="5" fill="#2196F3"/>
            <circle cx="325" cy="250" r="5" fill="#2196F3"/>
            <circle cx="400" cy="197" r="5" fill="#2196F3"/>
            <circle cx="480" cy="151" r="5" fill="#2196F3"/>
            <circle cx="560" cy="92" r="5" fill="#2196F3"/>

            <!-- Leyenda -->
            <rect x="420" y="35" width="15" height="15" fill="#c41e3a"/>
            <text x="440" y="47" font-size="12">Merge Sort</text>
            <rect x="420" y="55" width="15" height="15" fill="#2196F3"/>
            <text x="440" y="67" font-size="12">Heap Sort</text>

            <!-- Titulo ejes -->
            <text x="320" y="318" font-size="12" text-anchor="middle">Tamano de entrada (elementos)</text>
            <text x="20" y="155" font-size="12" text-anchor="middle" transform="rotate(-90, 20, 155)">Tiempo (s)</text>
        </svg>
    </div>

    <h4>Grafica 2: Comparacion Directa por Barras</h4>
    <div class="chart-container">
        <div class="chart-title">Comparacion de Tiempos por Tamano de Entrada</div>
        <div class="bar-chart">
            <div class="bar-row">
                <div class="bar-label">115</div>
                <div class="bar-container">
                    <div class="bar bar-merge" style="width: 15%;">0.00075s</div>
                    <div class="bar bar-heap" style="width: 20%;">0.00108s</div>
                </div>
            </div>
            <div class="bar-row">
                <div class="bar-label">211</div>
                <div class="bar-container">
                    <div class="bar bar-merge" style="width: 20%;">0.00168s</div>
                    <div class="bar bar-heap" style="width: 24%;">0.00204s</div>
                </div>
            </div>
            <div class="bar-row">
                <div class="bar-label">324</div>
                <div class="bar-container">
                    <div class="bar bar-merge" style="width: 28%;">0.00297s</div>
                    <div class="bar bar-heap" style="width: 30%;">0.00311s</div>
                </div>
            </div>
            <div class="bar-row">
                <div class="bar-label">444</div>
                <div class="bar-container">
                    <div class="bar bar-merge" style="width: 30%;">0.00304s</div>
                    <div class="bar bar-heap" style="width: 55%;">0.00597s</div>
                </div>
            </div>
            <div class="bar-row">
                <div class="bar-label">624</div>
                <div class="bar-container">
                    <div class="bar bar-merge" style="width: 40%;">0.00503s</div>
                    <div class="bar bar-heap" style="width: 68%;">0.00890s</div>
                </div>
            </div>
            <div class="bar-row">
                <div class="bar-label">1055</div>
                <div class="bar-container">
                    <div class="bar bar-merge" style="width: 55%;">0.01591s</div>
                    <div class="bar bar-heap" style="width: 80%;">0.02502s</div>
                </div>
            </div>
            <div class="bar-row">
                <div class="bar-label">1583</div>
                <div class="bar-container">
                    <div class="bar bar-merge" style="width: 65%;">0.02210s</div>
                    <div class="bar bar-heap" style="width: 90%;">0.03881s</div>
                </div>
            </div>
            <div class="bar-row">
                <div class="bar-label">2110</div>
                <div class="bar-container">
                    <div class="bar bar-merge" style="width: 85%;">0.04891s</div>
                    <div class="bar bar-heap" style="width: 98%;">0.05652s</div>
                </div>
            </div>
        </div>
        <div style="text-align: center; margin-top: 15px; font-size: 12px;">
            <span style="display: inline-block; width: 15px; height: 15px; background: linear-gradient(90deg, #c41e3a, #e53935); vertical-align: middle;"></span> Merge Sort &nbsp;&nbsp;
            <span style="display: inline-block; width: 15px; height: 15px; background: linear-gradient(90deg, #1976D2, #2196F3); vertical-align: middle;"></span> Heap Sort
        </div>
    </div>

    <h4>Grafica 3: Verificacion de Complejidad O(n log n)</h4>
    <div class="chart-container">
        <div class="chart-title">Crecimiento Real vs Teorico O(n log n)</div>
        <svg viewBox="0 0 600 280">
            <!-- Ejes -->
            <line x1="60" y1="240" x2="580" y2="240" stroke="#333" stroke-width="2"/>
            <line x1="60" y1="240" x2="60" y2="30" stroke="#333" stroke-width="2"/>

            <!-- Grid -->
            <line x1="60" y1="190" x2="580" y2="190" stroke="#e0e0e0" stroke-width="1"/>
            <line x1="60" y1="140" x2="580" y2="140" stroke="#e0e0e0" stroke-width="1"/>
            <line x1="60" y1="90" x2="580" y2="90" stroke="#e0e0e0" stroke-width="1"/>

            <!-- Curva teorica O(n log n) - linea punteada -->
            <path d="M 85,235 Q 200,220 320,170 T 560,60"
                  fill="none" stroke="#999" stroke-width="2" stroke-dasharray="8,4"/>

            <!-- Puntos reales Merge Sort -->
            <polyline
                points="85,237 145,233 205,228 265,227 325,220 400,180 480,155 560,70"
                fill="none" stroke="#c41e3a" stroke-width="2"/>

            <circle cx="85" cy="237" r="4" fill="#c41e3a"/>
            <circle cx="145" cy="233" r="4" fill="#c41e3a"/>
            <circle cx="205" cy="228" r="4" fill="#c41e3a"/>
            <circle cx="265" cy="227" r="4" fill="#c41e3a"/>
            <circle cx="325" cy="220" r="4" fill="#c41e3a"/>
            <circle cx="400" cy="180" r="4" fill="#c41e3a"/>
            <circle cx="480" cy="155" r="4" fill="#c41e3a"/>
            <circle cx="560" cy="70" r="4" fill="#c41e3a"/>

            <!-- Leyenda -->
            <line x1="400" y1="42" x2="430" y2="42" stroke="#c41e3a" stroke-width="2"/>
            <circle cx="415" cy="42" r="4" fill="#c41e3a"/>
            <text x="440" y="46" font-size="11">Tiempo Real</text>

            <line x1="400" y1="60" x2="430" y2="60" stroke="#999" stroke-width="2" stroke-dasharray="8,4"/>
            <text x="440" y="64" font-size="11">O(n log n) Teorico</text>

            <!-- Etiquetas -->
            <text x="320" y="268" font-size="12" text-anchor="middle">n (elementos)</text>
            <text x="25" y="135" font-size="12" text-anchor="middle" transform="rotate(-90, 25, 135)">Tiempo (normalizado)</text>
        </svg>
    </div>

    <h3>5.4 Analisis de Resultados</h3>

    <h4>5.4.1 Comportamiento General</h4>
    <ol>
        <li><strong>Ambas soluciones muestran crecimiento O(n log n):</strong> Los tiempos de ejecucion
            crecen de manera consistente con el tamano de entrada, siguiendo la curva teorica esperada.</li>
        <li><strong>Merge Sort es consistentemente mas rapido:</strong> En todas las pruebas, la
            Solucion 1 supera a la Solucion 2 en rendimiento.</li>
        <li><strong>La diferencia varia segun el tamano:</strong> Para entradas pequenas la diferencia
            es menor, pero puede ampliarse significativamente en ciertos casos.</li>
    </ol>

    <h4>5.4.2 Razones de la Diferencia de Rendimiento</h4>
    <table>
        <thead>
            <tr>
                <th>Factor</th>
                <th>Merge Sort</th>
                <th>Heap Sort</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Cache locality</td>
                <td style="color: green;">Mejor (acceso secuencial)</td>
                <td style="color: #c41e3a;">Peor (saltos en heap)</td>
            </tr>
            <tr>
                <td>Overhead de estructura</td>
                <td style="color: green;">Listas simples</td>
                <td style="color: #c41e3a;">Diccionarios + conversion</td>
            </tr>
            <tr>
                <td>Operaciones por elemento</td>
                <td style="color: green;">Menos comparaciones</td>
                <td style="color: #c41e3a;">Mas operaciones de sift</td>
            </tr>
        </tbody>
    </table>

    <h4>5.4.3 Verificacion de Complejidad Teorica</h4>
    <p>Para verificar que el comportamiento es O(n log n), calculamos la razon T(n) / (n log n):</p>
    <table>
        <thead>
            <tr>
                <th>n</th>
                <th>T(n)</th>
                <th>n log n</th>
                <th>T(n) / (n log n)</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>115</td>
                <td>0.00075</td>
                <td>540</td>
                <td>1.39 x 10<sup>-6</sup></td>
            </tr>
            <tr>
                <td>624</td>
                <td>0.00503</td>
                <td>3997</td>
                <td>1.26 x 10<sup>-6</sup></td>
            </tr>
            <tr>
                <td>2110</td>
                <td>0.04891</td>
                <td>16134</td>
                <td>3.03 x 10<sup>-6</sup></td>
            </tr>
        </tbody>
    </table>

    <div class="success-box">
        <strong>Conclusion:</strong> La razon se mantiene relativamente constante, confirmando
        el comportamiento O(n log n) de ambas implementaciones.
    </div>

    <h3>5.5 Verificacion con Caso del Enunciado</h3>
    <p>Se verifico que ambas soluciones producen la salida correcta para el ejemplo del enunciado:</p>

    <div class="success-box">
        <strong>Salida obtenida (correcta):</strong><br><br>
        <code>
        Sede Cali, Rendimiento: 55.5<br>
        &nbsp;&nbsp;Futbol: {2, 10}<br>
        &nbsp;&nbsp;Volleyball: {6, 1, 12, 9}<br><br>
        Sede Medellin, Rendimiento: 60.33<br>
        &nbsp;&nbsp;Volleyball: {3, 5, 4}<br>
        &nbsp;&nbsp;Futbol: {7, 8, 11}<br><br>
        Ranking Jugadores: {3, 2, 7, 6, 5, 10, 1, 4, 12, 8, 11, 9}<br><br>
        Equipo con mayor rendimiento: Futbol Sede Medellin<br>
        Equipo con menor rendimiento: Futbol Sede Cali<br>
        Jugador con mayor rendimiento: {9, Isabella Diaz, 92}<br>
        Jugador con menor rendimiento: {3, Valentina Rodriguez, 15}<br>
        Jugador mas joven: {10, Daniel Ruiz, 17}<br>
        Jugador mas veterano: {5, Martina Martinez, 30}<br>
        Promedio de edad: 23.25<br>
        Promedio de rendimiento: 60.42
        </code>
    </div>

    <div class="page-break"></div>

    <!-- 6. CONCLUSIONES -->
    <h2 id="conclusiones">6. Conclusiones</h2>

    <h3>6.1 Conclusiones Tecnicas</h3>
    <ol>
        <li><strong>Implementacion exitosa de dos soluciones distintas:</strong> Se lograron implementar
            dos soluciones utilizando diferentes estructuras de datos (listas vs diccionarios) y
            algoritmos de ordenamiento (Merge Sort vs Heap Sort), cumpliendo con el requisito de
            diferenciacion.</li>

        <li><strong>Ambos algoritmos cumplen con O(n log n):</strong> Los resultados experimentales
            confirman que tanto Merge Sort como Heap Sort mantienen la complejidad teorica esperada,
            validando las implementaciones manuales.</li>

        <li><strong>Merge Sort demuestra mejor rendimiento practico:</strong> A pesar de tener la
            misma complejidad asintotica, Merge Sort supera consistentemente a Heap Sort debido a:
            <ul>
                <li>Mejor uso de cache por acceso secuencial a memoria</li>
                <li>Menor overhead en la manipulacion de estructuras de datos</li>
                <li>Patrones de acceso mas predecibles para el CPU</li>
            </ul>
        </li>

        <li><strong>Los diccionarios agregan overhead:</strong> Aunque los diccionarios ofrecen
            busqueda O(1), en este problema no se aprovecha esa ventaja, y la conversion entre
            estructuras agrega costo computacional.</li>
    </ol>

    <h3>6.2 Conclusiones sobre el Diseno</h3>
    <ol>
        <li><strong>La eleccion de estructuras de datos impacta el rendimiento:</strong> Aunque
            teoricamente ambas soluciones son O(n log n), la implementacion practica muestra
            diferencias significativas (hasta 96% en algunos casos).</li>

        <li><strong>La simplicidad puede ser ventajosa:</strong> La Solucion 1, siendo mas simple
            en su estructura, resulto mas eficiente que la Solucion 2.</li>

        <li><strong>El analisis teorico no es suficiente:</strong> Es fundamental complementar el
            analisis de complejidad con pruebas experimentales para entender el comportamiento real.</li>
    </ol>

    <h3>6.3 Experiencia Adquirida</h3>
    <ol>
        <li><strong>Implementacion manual de algoritmos:</strong> El proyecto permitio profundizar
            en la comprension de Merge Sort y Heap Sort al implementarlos desde cero.</li>

        <li><strong>Manejo de criterios de desempate:</strong> Se aprendio a adaptar algoritmos de
            ordenamiento para manejar multiples criterios de comparacion de manera estable.</li>

        <li><strong>Medicion y analisis de rendimiento:</strong> Se desarrollo habilidad para medir
            tiempos de ejecucion, generar datos de prueba y analizar resultados experimentales.</li>

        <li><strong>Importancia del testing:</strong> Las pruebas con el caso del enunciado fueron
            fundamentales para validar la correctitud de las implementaciones.</li>
    </ol>

    <h3>6.4 Recomendaciones</h3>
    <div class="info-box">
        <ol>
            <li><strong>Para este tipo de problema, Merge Sort con listas es preferible</strong>
                debido a su mejor rendimiento practico y simplicidad de implementacion.</li>

            <li><strong>Los diccionarios serian utiles si se requiriera busqueda frecuente por ID</strong>,
                pero para ordenamiento puro las listas son mas eficientes.</li>

            <li><strong>En aplicaciones reales, considerar algoritmos hibridos</strong> como Timsort
                que combinan lo mejor de varios enfoques.</li>
        </ol>
    </div>

    <!-- ANEXOS -->
    <h2>Anexos</h2>

    <h3>A. Instrucciones de Ejecucion</h3>
    <pre><code><span class="comment"># Solucion 1 - Merge Sort</span>
python Solucion1.py input_guide.txt
python Solucion1.py inputs_tamanos/input_1000.txt

<span class="comment"># Solucion 2 - Heap Sort</span>
python Solucion2.py input_guide.txt
python Solucion2.py inputs_tamanos/input_1000.txt</code></pre>

    <h3>B. Archivos de Prueba</h3>
    <table>
        <thead>
            <tr>
                <th>Archivo</th>
                <th>Elementos</th>
                <th>Descripcion</th>
            </tr>
        </thead>
        <tbody>
            <tr><td>input_guide.txt</td><td>12</td><td>Caso del enunciado</td></tr>
            <tr><td>input_100.txt</td><td>100</td><td>Prueba pequena</td></tr>
            <tr><td>input_400.txt</td><td>400</td><td>Prueba mediana</td></tr>
            <tr><td>input_1000.txt</td><td>1000</td><td>Prueba grande</td></tr>
            <tr><td>input_2000.txt</td><td>2000</td><td>Prueba muy grande</td></tr>
        </tbody>
    </table>

    <h3>C. Referencias</h3>
    <ol>
        <li>Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2009).
            <em>Introduction to Algorithms</em> (3rd ed.). MIT Press.</li>
        <li>Material del curso "Analisis y Diseno de Algoritmos I" - Universidad del Valle.</li>
    </ol>

    <!-- FOOTER -->
    <div class="footer">
        <p><strong>Universidad del Valle</strong></p>
        <p>Facultad de Ingenieria - Escuela de Ingenieria de Sistemas y Computacion</p>
        <p>Diciembre 2025</p>
    </div>

</body>
</html>
